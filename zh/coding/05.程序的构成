程序的构成
==========

在开始讲计算机和程序设计的任何内容之前，有必要知道当你用编译器编译一个Ｃ文件或者汇编文件
后，生成的二进制代码里，都有哪些东西，以及为什么要这么组织。

但在此之前，我要要先复习一下历史，约定一些概念。

程序是怎样炼成的
----------------

最先开始中，程序员们是用打孔的纸带来写程序的。那时候已经有了类似通用计算机的概念，
但存储系统还很不发达，程序的指今实际上只用纸带上孔的位置和组合来确定的。一条纸带
就是一个程序，每一个程序的运行，都意味着纸带需要被移动一下。可以想像这一过程有多慢。
但是，这在当时已经远远超过了人的计算能力。不管怎样，纸带的移动也是自动完成的，不需要
人的干预。

就像第一次工业革命完成的标志是机器制造机器（其实是不完全的机器制造机器，其中很多环节，
因为缺少信息技术的支持，无法自动化），第一次软件技术的革命完成的标志应该是程序制造程序。

随着计算机能力的越来越强大，越来越通用化，产生了汇编语言。这是一种可以在文本编辑器中输入
机器指令的可读形式，然后由编译器生成最终可以在机器上执行的代码。比如，机器上一条内存读取
指令实际上是一个二进制的值：`10100010100...`，但是让人去记住这些组合不切实际。所以产生了
一种用文本指令带替二进程机器指令的形式：`ldr #0x3000`。然后，一个专门设计的程序会把
指令翻译成相应的二进制格式。这就是汇编语言和编译器的由来。汇编语言规定书写程序的语法，而
编译器则按照预先约定的语法把一个汇编语言的文本文件翻译成一个二进制的文件，也就是机器可以
执行的程序。程序产生程序，第一次极大的提高了程序的开发效率。

汇编语言直接对应每一条机器指令。汇编语言只是一个机器语言的助记符，用几个字母代替了1和0的组合。

后来人们发现用汇编语言开发程序，还是效率很低，而且每一条汇编指令都与它将要运行的处理器支持的指令完全一致，
导致如果想把一个上万行的程序移植到一个新的不同指令集的处理器上，每一条指令都要重新去写，甚至
新的处理器支持不了的旧处理器上的指令还要用好几个新处理器上的指令来模拟，导致工作量巨大。

专家们发现，汇编语言的功能可以抽象成一些更简单的元素，如赋值操作，算术运算，函数调用等等。
基于此，研究人员设计了一种新的更上层的语言：Ｃ语言和相应的Ｃ编译器。Ｃ编译器先把Ｃ语言
的文件转化成汇编语言，然后汇编编译器再把汇编语言转换成最终的可执行代码。这样，用Ｃ语言写的
程序在不同处理器平台上不需要改动，只要有相应平台上的Ｃ编译器和汇编编译器就可以了。

下面是一小段汇编程序的代码：

    #!asm
    global_x: .word 5
    global_y: .word 0
    global_z: .word 0
    str_x: .ascii "Hello Earth."
    main:
        push local_str_x /* local_str_x set up before main is called */
        push local_str_y /* local_str_y set up point to str_x before main is called */
        jmp printf

下面是一小段Ｃ代码：

    #!c
    int global_x = 5;
    int global_y = 0;
    int global_z;

    int main(void)
    {
        int local_x = 5;
        int local_y = 0;
        int local_z;

        char local_str_x[] = "Hello World.";
        char *local_str_y = "Hello Earth.";

        printf("%s \n %s \n", local_str_x, local_str_y);

        return 0;
    }

上面的两小段代码隐去了一些堆栈建立的细节，堆栈的概念会在后面讲到。
这里只是给大家一个概念，啥是汇编，啥是C语言。

现在，大部分操作系统和底层硬件相关的程序设计都是用C。好的设计会尽可能少的用汇编代码，但
是在一些关键的与硬件关系过于密切的地方，一些汇编指令是不可避免的。

程序的基本结构：指令、数据和堆栈
--------------------------------

程序的最基本构成单元是指令和数据。指令就是CPU执行的命令。数据就是程序需要存储的计算中间值和结果。
对于汇编语言，有这两个要素就可以实现大部分程序的设计。引入C语言后，就必需加入堆栈的概念。因为C语言
的基本抽象单位是函数，各个函数间相互调用，就必需保存函数的执行状态。当一个函数返回的时候，它的调用者
可以继续运行：

    #!c
    int main(void)
    {
        do_first_thing();
        do_second_thing();
        ...
        do_last_thing();

        return 0;
    }

一般来说，在C程序开始执行前（从CPU reset开始算起），必需要有一点点的汇编语言建立起一个基本的C语言运行环境：
即建立一个栈。只要有了栈，*简单的*C程序就可以正常运行。如果要复杂的C程序可以运行，还必需有BSS区域的初始化和堆的初始化。

C语言程序的构成
---------------

汇编语言有一个概念叫“区域”。一个区域一般存放属性相同的数据。在这里，程序指令本身也是数据，
这是[冯·诺伊曼](http://en.wikipedia.org/wiki/Von_Neumann_architecture)计算机系统的基本思想。
比如，一般把指令放在一个名称为`.text`的区域，初始化且不为零的全局数据放在一个叫`.data`的区域。
初使化为零或未出始化的全局数据放在一个叫`.bss`的区域。这三个区域一般一紧邻着的。

                 _____________
                |   stack     | <-- Adress high (top)
                |-------------|
                |     ||      |
                |     ||      |
                |     ||      |
                |     \/      |
                |             |
                |             |
                |             |
                |             |
                |     /\      |
                |     ||      |
                |     ||      |
                |     ||      |
                |-------------|
                |   heap      |
                |-------------|
                |   bss       |
                |-------------|
                |   data      |
                |-------------|
                |   text      |
                ===============  <-- Address 0x0
                                    
当一个C语言程序被编译成最终的可执行程序时，会有上图所示的这些段。

-   text: 存放程序指令
-   data: 存放初始化成非零的全局数据
-   bss: 存放初始化成零或未初始化的全局数据
-   heap: 动态内存分配区域，向“上”生长
-   stack: 函数调用栈，向下生长

这是一个非常自然而然的数据分区方法。

下一篇文章将讨论计算机的基本原理。
